// type inference
// generics, bounded by a union of structs
// bind (derive) structs
// no function overloading

// constant + variable type inferred
const abc = 12349;
var abc = 2359;

// no pointers, references
&abc

// struct union type annotated
const data: Rectangle | Car = ...;

// if statement
if (a == 2) {}

// for and while loops
for (var i = 0; i < 10; i++) {}
while (a < 10) { a++; }

// base function
fn name() {}

// function with parameters
fn name(param1: u32, param2: string) {}

// function with return
fn name(): string {}

// function with generic argument
fn [T] name(param: T) {}

// bind generics with struct unions
fn [T: Rectangle | Car] name(param: T) {}

// reference type parameter
fn name(param: &u32) {}

// modules by files
// export function from modules
exp fn name() {}

// structs
struct [T: Rectangle | Car] name {
  value1: bool;
  pub value2: T;
  pub static fn create(val1: bool, val2: T): name {
    return name {
      val1 = !val1,
      val2
    };
  }
  prot someFunc(): u32 {}
}

// inheriting from name (single inheritance)
struct something : name {
  // ...
}

// access member
// mutable if not defined with const
thing.size
thing.size = 3;
