// decleration
let num1 = 2;
// with annotation
let typedNum: u32 = 2;

// mutability
// mutability is an opt in feature signaled by the keyword mut
let mut num2 = 4;

// mut to const, const to mut
// const to const and mut to mut are obviously just fine
// this operation is mut to const, all good
let num3 = num2;
// this operation is mut to const, which is only an issue for NON-PRIMITIVE types
// since a is u32, u32 is primitive, al good
let mut num4 = num1;

// since non primitive types are copied, being mut or const on the type level does not matter
// and basically means nothing
// example:
// mut u32 will be treated the same as u32
// this only makes a difference in function parameters, they are defined as variables where
// the mutability is inferred from the type, so then it becomes useful
// see 03_functions for more

// mut to const const to mut NON-PRIMITIVE
// see 04_structs for more on structs
// const to const and mut to mut are just fine
struct M {}
let m1 = M {};
let mut m2 = M {};
// this operation is const to mut but because f is a reference/pointer, this operation
// is bad, will throw error
// let mut m3 = m1;
// this operation is mut to const, which is fine
let m4 = m2;
// tightening the restriction is fine, loostening it is not

// strings
let str = "some string";

// booleans
let mut boolValue = false;
boolValue = true

// characters
let ch = 'b';

// number types:
// u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, f32, f64, f128
// by default numbers are u32/i32
// if you would like them to be a different type, they must be cast
// constants that are cast are understood at compile time

// by default u32
let anyNum1 = 123;
// by default i32
let anyNum2 = -123;

let numberU16 = u16(32);

// array slices
// unknown size array (eventually stored as struct with ptr and size)
let slice: u32[] = [1, 2, 3, 4];
// known struct array
let ab: u32[3] = [3, 2, 1];
// if the size is known at compile time then the size is optimized out of the slice so
// the slice is just a ptr, otherwise it is stored as struct with ptr and size
// initialize a large stack array without specifying each individual element with the
// initializer syntax:
// basic number example
let initSlice = [256usize]u32 with 0;
// struct example
struct Data { size: u32; }
let dataArr = [350usize]Data with Data { size = 10 };

// nullable
let mut numOrNull: ?u32 = null;
numOrNull = 4;

// pointers
let val1 = 2;
let ptr1: *u32 = &val1;

// mutable variable to const pointer
let val2 = 2;
let val3 = 4;
let mut ptr2: *u32 = &val2;
ptr2 = &val3;

// mutable variable to mutable pointer
let mut val4 = 1;
let mut val5 = 2;
let mut ptr3: mut *u32 = mut &val4;
ptr3 = mut &val5;

// dereference pointer
let val6 = 5;
let ptr4 = &val6;
let ptrVal: u32 = *ptr4;

// heap allocation
// allocating to the heap works by using the 'new' keyword taking the following expression,
// evaluating it, then allocating space on the heap and moving it there. If the value is
// constant, or does not rely on an expression being evaluated, the new keyword will first
// allocate space on the heap then write into that instead of first the stack then moving
// using the 'new' keyword returns a pointer to the resulting type of the expression
